const mongoose = require("mongoose");

/**
 * ========================================================================
 * PROPERTY MODEL - MongoDB Schema cho Property Service
 * ========================================================================
 *
 * KI·∫æN TR√öC MICROSERVICES:
 * ----------------------------------------------------------------
 *
 * 1. API Gateway (Port 4000)
 *    - C·ªïng v√†o duy nh·∫•t t·ª´ Frontend (React Port 3000)
 *    - ƒê·ªãnh tuy·∫øn requests ƒë·∫øn c√°c microservices
 *    - CORS: Allow origin http://localhost:3000
 *
 * 2. Auth Service (Port 4001)
 *    - Sign-in with Ethereum (verify signature)
 *    - T·∫°o JWT token
 *
 * 3. IPFS Service (Port 4002)
 *    - Upload files (images, documents, metadata JSON) l√™n IPFS/Pinata
 *    - Tr·∫£ v·ªÅ CID
 *
 * 4. Admin Service / Property Management Service (Port 4003)
 *    - CRUD b·∫•t ƒë·ªông s·∫£n
 *    - Build metadata NFT
 *    - G·ªçi IPFS Service ƒë·ªÉ upload
 *    - G·ªçi Blockchain Service ƒë·ªÉ mint NFT
 *    - S·ª≠ d·ª•ng Model n√†y ƒë·ªÉ l∆∞u/query MongoDB
 *
 * 5. Blockchain Service (Port 4004)
 *    - Service DUY NH·∫§T t∆∞∆°ng t√°c blockchain
 *    - Qu·∫£n l√Ω Admin private key
 *    - Mint NFT, List/Buy/Cancel marketplace
 *    - G·ª≠i signed transactions
 *
 * 6. Indexer Service (Background Worker - No Port)
 *    - L·∫Øng nghe Smart Contract events 24/7
 *    - Events: Transfer, ItemListed, ItemSold, ItemCanceled
 *    - C·∫¨P NH·∫¨T model n√†y khi c√≥ events (owner, marketplace, status...)
 *    - Connect: Ganache (Port 8545)
 *
 * 7. Query Service (Port 4005)
 *    - API read-only cho Frontend
 *    - ƒê·ªåC t·ª´ model n√†y (search, filter, pagination)
 *    - Optimized queries
 *
 * ----------------------------------------------------------------
 * PH√ÇN CHIA D·ªÆ LI·ªÜU:
 * ----------------------------------------------------------------
 *
 * üì¶ IPFS (Immutable - Kh√¥ng thay ƒë·ªïi):
 * --------------------------------
 * - name, description          : Th√¥ng tin c∆° b·∫£n BƒêS
 * - image                      : Primary image IPFS URL
 * - external_url               : Link trang chi ti·∫øt (VD: https://viepropchain.com/properties/123)
 * - attributes                 : C√°c thu·ªôc t√≠nh C·ªê ƒê·ªäNH (lo·∫°i, v·ªã tr√≠, s·ªë ph√≤ng, di·ªán t√≠ch...)
 * - legal_documents            : Gi·∫•y t·ªù ph√°p l√Ω (s·ªï h·ªìng, gi·∫•y ph√©p) - IPFS URLs
 *
 * L∆ØU √ù: D·ªØ li·ªáu tr√™n IPFS KH√îNG th·ªÉ s·ª≠a/x√≥a sau khi upload!
 *
 * üóÑÔ∏è MONGODB (Mutable - C√≥ th·ªÉ thay ƒë·ªïi):
 * -----------------------------------
 * - tokenId, contractAddress   : ƒê·ªãnh danh on-chain
 * - nft.owner                  : Owner hi·ªán t·∫°i (C·∫¨P NH·∫¨T b·ªüi Indexer khi c√≥ Transfer event)
 * - marketplace.*              : Th√¥ng tin marketplace (C·∫¨P NH·∫¨T b·ªüi Indexer khi c√≥ ItemListed/Sold/Canceled events)
 * - status                     : 'draft' | 'published' | 'minted' | 'listed' | 'sold' | 'archived'
 * - price                      : Gi√° b√°n hi·ªán t·∫°i (thay ƒë·ªïi khi list/update)
 * - auctionInfo                : Th√¥ng tin ƒë·∫•u gi√° (n·∫øu c√≥)
 * - analytics                  : views, favorites, shares (C·∫¨P NH·∫¨T b·ªüi Query Service)
 *
 * CACHE t·ª´ IPFS (ƒë·ªÉ query nhanh):
 * - name, description, imageUrl, attributes
 * ‚Üí Query Service kh√¥ng c·∫ßn g·ªçi IPFS m·ªói l·∫ßn query!
 *
 * ----------------------------------------------------------------
 * NGUY√äN T·∫ÆC:
 * ----------------------------------------------------------------
 * ‚úÖ D·ªØ li·ªáu C·ªê ƒê·ªäNH (nh∆∞ CMT, s·ªï ƒë·ªè, s·ªë ph√≤ng) ‚Üí IPFS
 * ‚úÖ D·ªØ li·ªáu THAY ƒê·ªîI (gi√°, owner, status, views) ‚Üí MongoDB
 * ‚úÖ Cache metadata t·ª´ IPFS ‚Üí MongoDB (tƒÉng t·ªëc query)
 * ‚úÖ Indexer Service t·ª± ƒë·ªông sync blockchain events ‚Üí MongoDB
 * ‚úÖ Query Service ch·ªâ ƒê·ªåC MongoDB (kh√¥ng ghi)
 * ‚úÖ Blockchain Service l√† duy nh·∫•t c√≥ private key v√† g·ª≠i transactions
 *
 */

const propertySchema = new mongoose.Schema(
  {
    // ============================================================
    // SECTION 1: BASIC INFORMATION (Cache t·ª´ IPFS)
    // ============================================================
    propertyType: {
      type: String,
      required: true,
      enum: ["apartment", "land", "house", "villa"],
    },

    name: {
      type: String,
      required: true,
      trim: true,
    },

    description: {
      type: String,
      required: true,
    },

    price: {
      amount: {
        type: Number,
        required: true,
      },
      currency: {
        type: String,
        default: "VND",
      },
    },

    // ========== LOCATION ==========
    location: {
      address: {
        type: String,
        required: true,
      },
      ward: String,
      district: String,
      city: String,
      coordinates: {
        latitude: Number,
        longitude: Number,
      },
    },

    // ========== PROPERTY DETAILS (Dynamic based on type) ==========
    details: {
      // Common fields
      area: {
        value: Number,
        unit: {
          type: String,
          default: "m2",
        },
      },

      // For Apartment
      projectName: String,
      apartmentCode: String,
      block: String,
      floor: Number,
      grossArea: String,
      netArea: String,
      bedrooms: Number,
      bathrooms: Number,
      balconyDirection: String,
      interiorStatus: String,

      // For Land
      landNumber: String,
      mapSheetNumber: String,
      gpsCoordinates: String,
      frontWidth: String,
      length: String,
      landType: String,
      zoning: String,
      roadFrontage: String,

      // For House/Villa
      landArea: String,
      constructionArea: String,
      usableArea: String,
      structure: String,
      houseDirection: String,
      constructionYear: Number,

      // Legal status
      legalStatus: String,

      // Additional attributes (flexible)
      additionalAttributes: [
        {
          trait_type: String,
          value: String,
        },
      ],
    },

    // ========== MEDIA ==========
    media: {
      images: [
        {
          url: String,
          caption: String,
          isPrimary: {
            type: Boolean,
            default: false,
          },
        },
      ],
      documents: [
        {
          name: String,
          url: String,
          type: String,
        },
      ],
      virtualTour: String,
    },

    // ============================================================
    // SECTION 2: BLOCKCHAIN & NFT INFORMATION
    // ============================================================
    // Th√¥ng tin li√™n k·∫øt v·ªõi smart contract v√† IPFS

    nft: {
      // ƒê√£ mint th√†nh NFT ch∆∞a?
      isMinted: {
        type: Boolean,
        default: false,
      },

      // Token ID tr√™n blockchain (unique identifier on-chain)
      tokenId: {
        type: Number,
        index: true,
      },

      // Contract address (VD: 0x52B42Ac0e051A4c3386791b04391510C3cE06632)
      contractAddress: String,

      // Owner hi·ªán t·∫°i (ƒë·ªãa ch·ªâ v√≠) - C·∫¨P NH·∫¨T t·ª´ Transfer events
      // L∆ØU √ù: Field n√†y ƒë∆∞·ª£c sync t·ª± ƒë·ªông t·ª´ blockchain qua eventListener
      owner: {
        type: String,
        lowercase: true,
        index: true,
      },

      // Token URI (link ƒë·∫øn metadata IPFS)
      // VD: ipfs://QmXXX... ho·∫∑c https://gateway.pinata.cloud/ipfs/QmXXX...
      tokenURI: String,

      // Transaction hash khi mint
      transactionHash: String,

      // IPFS hash c·ªßa metadata (QmXXX...)
      ipfsHash: String,

      // Timestamp khi mint
      mintedAt: Date,
    },

    // ============================================================
    // SECTION 3: IPFS METADATA CID
    // ============================================================
    // L∆∞u IPFS CID c·ªßa metadata ƒë·ªÉ c√≥ th·ªÉ fetch l·∫°i n·∫øu c·∫ßn
    ipfsMetadataCid: {
      type: String,
      default: null,
    },

    // ============================================================
    // SECTION 4: STATUS & MANAGEMENT (D·ªØ li·ªáu thay ƒë·ªïi)
    // ============================================================
    // C√°c th√¥ng tin n√†y KH√îNG l∆∞u tr√™n IPFS v√¨ thay ƒë·ªïi th∆∞·ªùng xuy√™n
    // Tr·∫°ng th√°i BƒêS - THAY ƒê·ªîI theo s·ª± ki·ªán blockchain
    status: {
      type: String,
      enum: [
        "draft", // ƒêang so·∫°n th·∫£o
        "published", // ƒê√£ publish, ch∆∞a mint
        "pending_mint", // ƒêang ch·ªù mint
        "minted", // ƒê√£ mint th√†nh NFT
        "for_sale", // ƒêang rao b√°n (c√≥ ng∆∞·ªùi list)
        "in_transaction", // ƒêang trong giao d·ªãch
        "sold", // ƒê√£ b√°n
        "archived", // ƒê√£ l∆∞u tr·ªØ
      ],
      default: "draft",
      index: true,
    },

    // ============================================================
    // SECTION 5: PRICE & AUCTION INFO (D·ªØ li·ªáu thay ƒë·ªïi)
    // ============================================================
    // Th√¥ng tin gi√° v√† ƒë·∫•u gi√° - ƒê·ªíNG B·ªò t·ª´ smart contract events

    // Gi√° ni√™m y·∫øt hi·ªán t·∫°i (c√≥ th·ªÉ thay ƒë·ªïi)
    // C·∫¨P NH·∫¨T khi c√≥ s·ª± ki·ªán List/UpdatePrice t·ª´ smart contract
    listingPrice: {
      amount: {
        type: Number,
        default: 0,
      },
      currency: {
        type: String,
        default: "VND",
      },
      updatedAt: Date,
    },

    // Th√¥ng tin ƒë·∫•u gi√° (n·∫øu c√≥)
    auctionInfo: {
      isActive: {
        type: Boolean,
        default: false,
      },
      startPrice: Number,
      currentBid: Number,
      highestBidder: String,
      endTime: Date,
      bids: [
        {
          bidder: String,
          amount: Number,
          timestamp: Date,
        },
      ],
    },

    // ============================================================
    // SECTION 6: OWNER & AGENT INFO
    // ============================================================

    // Th√¥ng tin owner (ng∆∞·ªùi s·ªü h·ªØu off-chain)
    owner: {
      userId: String,
      walletAddress: String,
      name: String,
      email: String,
    },

    // Th√¥ng tin agent (m√¥i gi·ªõi)
    agent: {
      userId: String,
      name: String,
      phone: String,
      email: String,
    },

    // ============================================================
    // SECTION 7: ANALYTICS (D·ªØ li·ªáu thay ƒë·ªïi li√™n t·ª•c)
    // ============================================================
    // C√°c metrics n√†y ch·ªâ d√πng cho hi·ªÉn th·ªã, KH√îNG l∆∞u tr√™n IPFS

    analytics: {
      // S·ªë l∆∞·ª£t xem (tƒÉng m·ªói khi user xem chi ti·∫øt)
      views: {
        type: Number,
        default: 0,
      },

      // S·ªë l∆∞·ª£t y√™u th√≠ch
      favorites: {
        type: Number,
        default: 0,
      },

      // S·ªë l∆∞·ª£t chia s·∫ª
      shares: {
        type: Number,
        default: 0,
      },

      // S·ªë l∆∞·ª£t h·ªèi th√¥ng tin
      inquiries: {
        type: Number,
        default: 0,
      },
    },

    // ========== METADATA ==========
    isPublic: {
      type: Boolean,
      default: true,
    },

    isFeatured: {
      type: Boolean,
      default: false,
    },

    tags: [String],

    // ========== TIMESTAMPS ==========
    createdAt: {
      type: Date,
      default: Date.now,
    },

    updatedAt: {
      type: Date,
      default: Date.now,
    },

    publishedAt: Date,
  },
  {
    timestamps: true,
  }
);

// ============================================================
// DATABASE INDEXES (T·ªëi ∆∞u query performance)
// ============================================================

// Index cho query theo lo·∫°i v√† tr·∫°ng th√°i
propertySchema.index({ propertyType: 1, status: 1 });

// Index cho query theo v·ªã tr√≠
propertySchema.index({ "location.city": 1, "location.district": 1 });

// Index cho query theo gi√°
propertySchema.index({ "price.amount": 1 });
propertySchema.index({ "listingPrice.amount": 1 });

// Index cho query NFT (on-chain data)
propertySchema.index({ "nft.tokenId": 1 });
propertySchema.index({ "nft.owner": 1 });
propertySchema.index({ "nft.isMinted": 1 });

// Index cho query owner
propertySchema.index({ "owner.walletAddress": 1 });

// Index cho s·∫Øp x·∫øp theo th·ªùi gian
propertySchema.index({ createdAt: -1 });
propertySchema.index({ updatedAt: -1 });

// Text search index (t√¨m ki·∫øm full-text)
propertySchema.index({
  name: "text",
  description: "text",
  "location.address": "text",
});

// ============================================================
// INSTANCE METHODS
// ============================================================

/**
 * TƒÉng s·ªë l∆∞·ª£t xem
 * S·ª≠ d·ª•ng: property.incrementViews()
 */
propertySchema.methods.incrementViews = function () {
  this.analytics.views += 1;
  return this.save();
};

/**
 * TƒÉng s·ªë l∆∞·ª£t y√™u th√≠ch
 * S·ª≠ d·ª•ng: property.incrementFavorites()
 */
propertySchema.methods.incrementFavorites = function () {
  this.analytics.favorites += 1;
  return this.save();
};

/**
 * C·∫≠p nh·∫≠t tr·∫°ng th√°i BƒêS
 * S·ª≠ d·ª•ng: property.updateStatus('for_sale')
 */
propertySchema.methods.updateStatus = function (newStatus) {
  this.status = newStatus;
  this.updatedAt = new Date();
  return this.save();
};

/**
 * ƒê√°nh d·∫•u BƒêS ƒë√£ ƒë∆∞·ª£c mint th√†nh NFT
 * QUAN TR·ªåNG: Method n√†y ƒë∆∞·ª£c g·ªçi sau khi mint th√†nh c√¥ng
 *
 * @param {Object} nftData - D·ªØ li·ªáu NFT t·ª´ minting service
 * @param {Number} nftData.tokenId - Token ID on-chain
 * @param {String} nftData.contractAddress - Contract address
 * @param {String} nftData.owner - Owner address
 * @param {String} nftData.tokenURI - IPFS URI
 * @param {String} nftData.transactionHash - Mint transaction hash
 * @param {String} nftData.ipfsHash - IPFS metadata hash
 */
propertySchema.methods.markAsMinted = function (nftData) {
  this.nft = {
    isMinted: true,
    tokenId: nftData.tokenId,
    contractAddress: nftData.contractAddress,
    owner: nftData.owner.toLowerCase(), // Normalize address
    tokenURI: nftData.tokenURI,
    transactionHash: nftData.transactionHash,
    ipfsHash: nftData.ipfsHash,
    mintedAt: new Date(),
  };
  this.status = "minted";
  this.updatedAt = new Date();
  return this.save();
};

/**
 * C·∫≠p nh·∫≠t owner khi NFT ƒë∆∞·ª£c transfer
 * QUAN TR·ªåNG: Method n√†y ƒë∆∞·ª£c g·ªçi khi ph√°t hi·ªán Transfer event t·ª´ blockchain
 *
 * @param {String} newOwner - ƒê·ªãa ch·ªâ owner m·ªõi
 * @param {String} transactionHash - Transfer transaction hash
 */
propertySchema.methods.updateOwner = function (newOwner, transactionHash) {
  if (!this.nft.isMinted) {
    throw new Error("Property is not minted as NFT yet");
  }

  this.nft.owner = newOwner.toLowerCase();
  this.updatedAt = new Date();

  console.log(`‚úÖ Updated owner for property ${this._id}: ${newOwner}`);
  console.log(`   Transaction: ${transactionHash}`);

  return this.save();
};

/**
 * C·∫≠p nh·∫≠t gi√° ni√™m y·∫øt
 * QUAN TR·ªåNG: Method n√†y ƒë∆∞·ª£c g·ªçi khi c√≥ event PriceUpdated t·ª´ smart contract
 *
 * @param {Number} amount - Gi√° m·ªõi
 * @param {String} currency - ƒê∆°n v·ªã ti·ªÅn t·ªá
 */
propertySchema.methods.updateListingPrice = function (
  amount,
  currency = "VND"
) {
  this.listingPrice = {
    amount: amount,
    currency: currency,
    updatedAt: new Date(),
  };
  this.updatedAt = new Date();

  console.log(
    `‚úÖ Updated listing price for property ${this._id}: ${amount} ${currency}`
  );

  return this.save();
};

// ========== STATIC METHODS ==========

// Get statistics
propertySchema.statics.getStatistics = async function () {
  const stats = await this.aggregate([
    {
      $group: {
        _id: null,
        totalProperties: { $sum: 1 },
        totalMinted: {
          $sum: { $cond: ["$nft.isMinted", 1, 0] },
        },
        totalViews: { $sum: "$analytics.views" },
        avgPrice: { $avg: "$price.amount" },
      },
    },
    {
      $group: {
        _id: "$propertyType",
        count: { $sum: 1 },
      },
    },
  ]);

  return stats;
};

// ========== VIRTUAL FIELDS ==========

propertySchema.virtual("primaryImage").get(function () {
  const primary = this.media.images.find((img) => img.isPrimary);
  return primary ? primary.url : this.media.images[0]?.url || null;
});

// Ensure virtuals are included in JSON
propertySchema.set("toJSON", { virtuals: true });
propertySchema.set("toObject", { virtuals: true });

// ========== HOOKS ==========

// Update timestamp before save
propertySchema.pre("save", function (next) {
  this.updatedAt = new Date();
  next();
});

const Property = mongoose.model("Property", propertySchema);

module.exports = Property;
