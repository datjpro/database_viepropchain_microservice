const mongoose = require("mongoose");

/**
 * ========================================================================
 * PROPERTY MODEL - Qu·∫£n l√Ω th√¥ng tin b·∫•t ƒë·ªông s·∫£n trong MongoDB
 * ========================================================================
 * 
 * PH√ÇN CHIA D·ªÆ LI·ªÜU:
 * ----------------------------------------------------------------
 * 
 * üì¶ IPFS (Immutable - Kh√¥ng ƒë·ªïi):
 * --------------------------------
 * - name, description          : Th√¥ng tin c∆° b·∫£n
 * - image                      : Link IPFS ·∫£nh ƒë·∫°i di·ªán
 * - external_url               : Link trang chi ti·∫øt
 * - attributes                 : C√°c thu·ªôc t√≠nh C·ªê ƒê·ªäNH (lo·∫°i, v·ªã tr√≠, di·ªán t√≠ch...)
 * - legal_documents            : Gi·∫•y t·ªù ph√°p l√Ω (IPFS links)
 * 
 * üóÑÔ∏è MONGODB (Mutable - C√≥ th·ªÉ ƒë·ªïi):
 * -----------------------------------
 * - tokenId, contractAddress   : ƒê·ªãnh danh on-chain
 * - ownerAddress               : Owner hi·ªán t·∫°i (thay ƒë·ªïi khi transfer)
 * - status                     : Tr·∫°ng th√°i (draft, published, for_sale, sold...)
 * - price                      : Gi√° b√°n (thay ƒë·ªïi khi ni√™m y·∫øt)
 * - auctionInfo                : Th√¥ng tin ƒë·∫•u gi√°
 * - name, imageUrl, attributes : CACHE t·ª´ IPFS (ƒë·ªÉ query nhanh)
 * - viewCount, favoriteCount   : Analytics (thay ƒë·ªïi li√™n t·ª•c)
 * 
 * NGUY√äN T·∫ÆC:
 * ----------------------------------------------------------------
 * ‚úÖ D·ªØ li·ªáu C·ªê ƒê·ªäNH (nh∆∞ CMT, s·ªï ƒë·ªè) ‚Üí L∆∞u tr√™n IPFS
 * ‚úÖ D·ªØ li·ªáu THAY ƒê·ªîI (gi√°, owner, status) ‚Üí L∆∞u tr√™n MongoDB
 * ‚úÖ Cache metadata t·ª´ IPFS ‚Üí MongoDB (tƒÉng t·ªëc query)
 * 
 */

const propertySchema = new mongoose.Schema(
  {
    // ============================================================
    // SECTION 1: BASIC INFORMATION (Cache t·ª´ IPFS)
    // ============================================================
    propertyType: {
      type: String,
      required: true,
      enum: ["apartment", "land", "house", "villa"],
    },

    name: {
      type: String,
      required: true,
      trim: true,
    },

    description: {
      type: String,
      required: true,
    },

    price: {
      amount: {
        type: Number,
        required: true,
      },
      currency: {
        type: String,
        default: "VND",
      },
    },

    // ========== LOCATION ==========
    location: {
      address: {
        type: String,
        required: true,
      },
      ward: String,
      district: String,
      city: String,
      coordinates: {
        latitude: Number,
        longitude: Number,
      },
    },

    // ========== PROPERTY DETAILS (Dynamic based on type) ==========
    details: {
      // Common fields
      area: {
        value: Number,
        unit: {
          type: String,
          default: "m2",
        },
      },

      // For Apartment
      projectName: String,
      apartmentCode: String,
      block: String,
      floor: Number,
      grossArea: String,
      netArea: String,
      bedrooms: Number,
      bathrooms: Number,
      balconyDirection: String,
      interiorStatus: String,

      // For Land
      landNumber: String,
      mapSheetNumber: String,
      gpsCoordinates: String,
      frontWidth: String,
      length: String,
      landType: String,
      zoning: String,
      roadFrontage: String,

      // For House/Villa
      landArea: String,
      constructionArea: String,
      usableArea: String,
      structure: String,
      houseDirection: String,
      constructionYear: Number,

      // Legal status
      legalStatus: String,

      // Additional attributes (flexible)
      additionalAttributes: [
        {
          trait_type: String,
          value: String,
        },
      ],
    },

    // ========== MEDIA ==========
    media: {
      images: [
        {
          url: String,
          caption: String,
          isPrimary: {
            type: Boolean,
            default: false,
          },
        },
      ],
      documents: [
        {
          name: String,
          url: String,
          type: String,
        },
      ],
      virtualTour: String,
    },

    // ============================================================
    // SECTION 2: BLOCKCHAIN & NFT INFORMATION
    // ============================================================
    // Th√¥ng tin li√™n k·∫øt v·ªõi smart contract v√† IPFS
    
    nft: {
      // ƒê√£ mint th√†nh NFT ch∆∞a?
      isMinted: {
        type: Boolean,
        default: false,
      },
      
      // Token ID tr√™n blockchain (unique identifier on-chain)
      tokenId: {
        type: Number,
        index: true,
      },
      
      // Contract address (VD: 0x52B42Ac0e051A4c3386791b04391510C3cE06632)
      contractAddress: String,
      
      // Owner hi·ªán t·∫°i (ƒë·ªãa ch·ªâ v√≠) - C·∫¨P NH·∫¨T t·ª´ Transfer events
      // L∆ØU √ù: Field n√†y ƒë∆∞·ª£c sync t·ª± ƒë·ªông t·ª´ blockchain qua eventListener
      owner: {
        type: String,
        lowercase: true,
        index: true,
      },
      
      // Token URI (link ƒë·∫øn metadata IPFS)
      // VD: ipfs://QmXXX... ho·∫∑c https://gateway.pinata.cloud/ipfs/QmXXX...
      tokenURI: String,
      
      // Transaction hash khi mint
      transactionHash: String,
      
      // IPFS hash c·ªßa metadata (QmXXX...)
      ipfsHash: String,
      
      // Timestamp khi mint
      mintedAt: Date,
    },

    // ============================================================
    // SECTION 3: IPFS METADATA CID
    // ============================================================
    // L∆∞u IPFS CID c·ªßa metadata ƒë·ªÉ c√≥ th·ªÉ fetch l·∫°i n·∫øu c·∫ßn
    ipfsMetadataCid: {
      type: String,
      default: null,
    },

    // ============================================================
    // SECTION 4: STATUS & MANAGEMENT (D·ªØ li·ªáu thay ƒë·ªïi)
    // ============================================================
    // C√°c th√¥ng tin n√†y KH√îNG l∆∞u tr√™n IPFS v√¨ thay ƒë·ªïi th∆∞·ªùng xuy√™n
    // Tr·∫°ng th√°i BƒêS - THAY ƒê·ªîI theo s·ª± ki·ªán blockchain
    status: {
      type: String,
      enum: [
        "draft",           // ƒêang so·∫°n th·∫£o
        "published",       // ƒê√£ publish, ch∆∞a mint
        "pending_mint",    // ƒêang ch·ªù mint
        "minted",          // ƒê√£ mint th√†nh NFT
        "for_sale",        // ƒêang rao b√°n (c√≥ ng∆∞·ªùi list)
        "in_transaction",  // ƒêang trong giao d·ªãch
        "sold",            // ƒê√£ b√°n
        "archived",        // ƒê√£ l∆∞u tr·ªØ
      ],
      default: "draft",
      index: true,
    },

    // ============================================================
    // SECTION 5: PRICE & AUCTION INFO (D·ªØ li·ªáu thay ƒë·ªïi)
    // ============================================================
    // Th√¥ng tin gi√° v√† ƒë·∫•u gi√° - ƒê·ªíNG B·ªò t·ª´ smart contract events
    
    // Gi√° ni√™m y·∫øt hi·ªán t·∫°i (c√≥ th·ªÉ thay ƒë·ªïi)
    // C·∫¨P NH·∫¨T khi c√≥ s·ª± ki·ªán List/UpdatePrice t·ª´ smart contract
    listingPrice: {
      amount: {
        type: Number,
        default: 0,
      },
      currency: {
        type: String,
        default: "VND",
      },
      updatedAt: Date,
    },

    // Th√¥ng tin ƒë·∫•u gi√° (n·∫øu c√≥)
    auctionInfo: {
      isActive: {
        type: Boolean,
        default: false,
      },
      startPrice: Number,
      currentBid: Number,
      highestBidder: String,
      endTime: Date,
      bids: [
        {
          bidder: String,
          amount: Number,
          timestamp: Date,
        },
      ],
    },

    // ============================================================
    // SECTION 6: OWNER & AGENT INFO
    // ============================================================
    
    // Th√¥ng tin owner (ng∆∞·ªùi s·ªü h·ªØu off-chain)
    owner: {
      userId: String,
      walletAddress: String,
      name: String,
      email: String,
    },

    // Th√¥ng tin agent (m√¥i gi·ªõi)
    agent: {
      userId: String,
      name: String,
      phone: String,
      email: String,
    },

    // ============================================================
    // SECTION 7: ANALYTICS (D·ªØ li·ªáu thay ƒë·ªïi li√™n t·ª•c)
    // ============================================================
    // C√°c metrics n√†y ch·ªâ d√πng cho hi·ªÉn th·ªã, KH√îNG l∆∞u tr√™n IPFS
    
    analytics: {
      // S·ªë l∆∞·ª£t xem (tƒÉng m·ªói khi user xem chi ti·∫øt)
      views: {
        type: Number,
        default: 0,
      },
      
      // S·ªë l∆∞·ª£t y√™u th√≠ch
      favorites: {
        type: Number,
        default: 0,
      },
      
      // S·ªë l∆∞·ª£t chia s·∫ª
      shares: {
        type: Number,
        default: 0,
      },
      
      // S·ªë l∆∞·ª£t h·ªèi th√¥ng tin
      inquiries: {
        type: Number,
        default: 0,
      },
    },

    // ========== METADATA ==========
    isPublic: {
      type: Boolean,
      default: true,
    },

    isFeatured: {
      type: Boolean,
      default: false,
    },

    tags: [String],

    // ========== TIMESTAMPS ==========
    createdAt: {
      type: Date,
      default: Date.now,
    },

    updatedAt: {
      type: Date,
      default: Date.now,
    },

    publishedAt: Date,
  },
  {
    timestamps: true,
  }
);

// ============================================================
// DATABASE INDEXES (T·ªëi ∆∞u query performance)
// ============================================================

// Index cho query theo lo·∫°i v√† tr·∫°ng th√°i
propertySchema.index({ propertyType: 1, status: 1 });

// Index cho query theo v·ªã tr√≠
propertySchema.index({ "location.city": 1, "location.district": 1 });

// Index cho query theo gi√°
propertySchema.index({ "price.amount": 1 });
propertySchema.index({ "listingPrice.amount": 1 });

// Index cho query NFT (on-chain data)
propertySchema.index({ "nft.tokenId": 1 });
propertySchema.index({ "nft.owner": 1 });
propertySchema.index({ "nft.isMinted": 1 });

// Index cho query owner
propertySchema.index({ "owner.walletAddress": 1 });

// Index cho s·∫Øp x·∫øp theo th·ªùi gian
propertySchema.index({ createdAt: -1 });
propertySchema.index({ updatedAt: -1 });

// Text search index (t√¨m ki·∫øm full-text)
propertySchema.index({
  name: "text",
  description: "text",
  "location.address": "text",
});

// ============================================================
// INSTANCE METHODS
// ============================================================

/**
 * TƒÉng s·ªë l∆∞·ª£t xem
 * S·ª≠ d·ª•ng: property.incrementViews()
 */
propertySchema.methods.incrementViews = function () {
  this.analytics.views += 1;
  return this.save();
};

/**
 * TƒÉng s·ªë l∆∞·ª£t y√™u th√≠ch
 * S·ª≠ d·ª•ng: property.incrementFavorites()
 */
propertySchema.methods.incrementFavorites = function () {
  this.analytics.favorites += 1;
  return this.save();
};

/**
 * C·∫≠p nh·∫≠t tr·∫°ng th√°i BƒêS
 * S·ª≠ d·ª•ng: property.updateStatus('for_sale')
 */
propertySchema.methods.updateStatus = function (newStatus) {
  this.status = newStatus;
  this.updatedAt = new Date();
  return this.save();
};

/**
 * ƒê√°nh d·∫•u BƒêS ƒë√£ ƒë∆∞·ª£c mint th√†nh NFT
 * QUAN TR·ªåNG: Method n√†y ƒë∆∞·ª£c g·ªçi sau khi mint th√†nh c√¥ng
 * 
 * @param {Object} nftData - D·ªØ li·ªáu NFT t·ª´ minting service
 * @param {Number} nftData.tokenId - Token ID on-chain
 * @param {String} nftData.contractAddress - Contract address
 * @param {String} nftData.owner - Owner address
 * @param {String} nftData.tokenURI - IPFS URI
 * @param {String} nftData.transactionHash - Mint transaction hash
 * @param {String} nftData.ipfsHash - IPFS metadata hash
 */
propertySchema.methods.markAsMinted = function (nftData) {
  this.nft = {
    isMinted: true,
    tokenId: nftData.tokenId,
    contractAddress: nftData.contractAddress,
    owner: nftData.owner.toLowerCase(), // Normalize address
    tokenURI: nftData.tokenURI,
    transactionHash: nftData.transactionHash,
    ipfsHash: nftData.ipfsHash,
    mintedAt: new Date(),
  };
  this.status = "minted";
  this.updatedAt = new Date();
  return this.save();
};

/**
 * C·∫≠p nh·∫≠t owner khi NFT ƒë∆∞·ª£c transfer
 * QUAN TR·ªåNG: Method n√†y ƒë∆∞·ª£c g·ªçi khi ph√°t hi·ªán Transfer event t·ª´ blockchain
 * 
 * @param {String} newOwner - ƒê·ªãa ch·ªâ owner m·ªõi
 * @param {String} transactionHash - Transfer transaction hash
 */
propertySchema.methods.updateOwner = function (newOwner, transactionHash) {
  if (!this.nft.isMinted) {
    throw new Error("Property is not minted as NFT yet");
  }
  
  this.nft.owner = newOwner.toLowerCase();
  this.updatedAt = new Date();
  
  console.log(`‚úÖ Updated owner for property ${this._id}: ${newOwner}`);
  console.log(`   Transaction: ${transactionHash}`);
  
  return this.save();
};

/**
 * C·∫≠p nh·∫≠t gi√° ni√™m y·∫øt
 * QUAN TR·ªåNG: Method n√†y ƒë∆∞·ª£c g·ªçi khi c√≥ event PriceUpdated t·ª´ smart contract
 * 
 * @param {Number} amount - Gi√° m·ªõi
 * @param {String} currency - ƒê∆°n v·ªã ti·ªÅn t·ªá
 */
propertySchema.methods.updateListingPrice = function (amount, currency = "VND") {
  this.listingPrice = {
    amount: amount,
    currency: currency,
    updatedAt: new Date(),
  };
  this.updatedAt = new Date();
  
  console.log(`‚úÖ Updated listing price for property ${this._id}: ${amount} ${currency}`);
  
  return this.save();
};

// ========== STATIC METHODS ==========

// Get statistics
propertySchema.statics.getStatistics = async function () {
  const stats = await this.aggregate([
    {
      $group: {
        _id: null,
        totalProperties: { $sum: 1 },
        totalMinted: {
          $sum: { $cond: ["$nft.isMinted", 1, 0] },
        },
        totalViews: { $sum: "$analytics.views" },
        avgPrice: { $avg: "$price.amount" },
      },
    },
    {
      $group: {
        _id: "$propertyType",
        count: { $sum: 1 },
      },
    },
  ]);

  return stats;
};

// ========== VIRTUAL FIELDS ==========

propertySchema.virtual("primaryImage").get(function () {
  const primary = this.media.images.find((img) => img.isPrimary);
  return primary ? primary.url : this.media.images[0]?.url || null;
});

// Ensure virtuals are included in JSON
propertySchema.set("toJSON", { virtuals: true });
propertySchema.set("toObject", { virtuals: true });

// ========== HOOKS ==========

// Update timestamp before save
propertySchema.pre("save", function (next) {
  this.updatedAt = new Date();
  next();
});

const Property = mongoose.model("Property", propertySchema);

module.exports = Property;
